# 迭代器与生成器

迭代是访问序列元素的一种方式，迭代从第一个元素开始访问，直到所有的元素被访问完结束，且只能往前不会后退。

## 迭代器

迭代器，就是迭代访问序列的一种实现。它是一种一边循环一边计算的机制，数据不是一次性全部获得，而是在访问时计算（惰性求值），这样可以节约大量的内存。`iter`可以获取迭代器。

```python
my_list = [1, 2, 3]
my_iter = iter(my_list)

print(f'第一个元素为: {next(my_iter)}')  
print(f'第二个元素为: {next(my_iter)}')  
print(f'第三个元素为: {next(my_iter)}')  
print(f'第四个元素为: {next(my_iter)}')  
```

* `next`关键字可以获取迭代器的下一个值。
* 根据规则循环生成数据，当条件不成立时则生成数据结束。
* 无法获得迭代元素值是抛出`StopIteration`异常。

`for`循环可以遍历迭代器中的每个值

```python
my_list = [1, 2, 3]
my_iter = iter(my_list)

for num in my_iter:
    print(f'第三个元素为: {num}')  
```

* 不需要处理`StopIteration`异常。
* 不需要使用`next`关键字，直接可以获得值。

使用`while`遍历迭代器，需要手动捕获异常。

```python
my_list = [1, 2, 3]
my_iter = iter(my_list)

while True:
    try:
        result = next(my_iter)
        print(f'当前元素为: {result}')
    except StopIteration as e:
        break
```



定义一个迭代器时，只要在类中实现了`__iter__()`和`__next__()`两个方法

```python
class FibonacciIterator:
    def __init__(self, max_count):
        self.max_count = max_count  
        self.count = 0              
        self.a = 0                  
        self.b = 1                  

    def __iter__(self):
        return self

    def __next__(self):
        if self.count >= self.max_count:
            raise StopIteration     

        if self.count == 0:
            self.count += 1
            return self.a          

        if self.count == 1:
            self.count += 1
            return self.b           

        next_value = self.a + self.b
        self.a = self.b
        self.b = next_value
        self.count += 1
        return next_value           


fib_iter = FibonacciIterator(10)
result = []
for num in fib_iter:
    result.append(num)

print(result)
```

* `__iter__`返回对象本身；`__next__`中返回每次迭代获得的字。

使用函数生成同样的序列

```python
def fibonacci(num):
    a = 0
    b = 1
    for _ in range(num):
        a, b = b, a + b

    return a

result = []
for num in range(10):
    result.append(fibonacci(num))

```

比较两种方法的运行时间

```python
def time_it(func):
    def wrapper(*args, **kwargs):
        start_time = time.time()
        result = func(*args, **kwargs)
        end_time = time.time()
        print(f"{func.__name__} took {end_time - start_time:.4f} seconds")
        return result
    return wrapper

@time_it
def def_fibonacci(num):
    result = []
    for i in range(num):
        result.append(fibonacci(i))

@time_it
def iter_fibonacci(num):
    result = []
    fib_iter = FibonacciIterator(num)
    for i in fib_iter:
        result.append(i)

def_ = def_fibonacci(5000)
iter_ = iter_fibonacci(5000)
```

> [!think]
>
> 问什么迭代器的效率远高于函数。

### 迭代器的特点

1. 状态保持：获取值之后不会结束，可以继续执行，直到迭代完成。

```python
fib_iter = FibonacciIterator(10)
result = []
for num in fib_iter:
    result.append(num)
    if num > 10:
        break

print(result)
print(next(fib_iter))
print(next(fib_iter))
print(next(fib_iter))
```

2. 惰性求值：只在需要时计算值，不预先计算所有结果。
3. 一次性遍历：遍历后无法重置，需要重新创建。

```python
fib_iter = FibonacciIterator(10)
result = []
for num in fib_iter:
    result.append(num)
print(f'result 结果为: {result}')

for num in fib_iter:
    print(f'当前元素为: {num}')
```

迭代器的核心优势

1. 内存高效：不需要一次性加载所有数据。
2. 惰性计算：按需计算，提高性能。
3. 无限序列：可以表示无限的数据流
4. 统一接口：一致的遍历方式

## 生成器

生成器是一种特殊的迭代器，是创建迭代器的一种简洁方式。

### 列表生成器

与列表推导式类似，只不过生成器推导式使用小括号。

```python
my_generator = (i for i in range(3))
print(my_generator)

print(f'当前元素为: {next(my_generator)}')
print(f'当前元素为: {next(my_generator)}')
print(f'当前元素为: {next(my_generator)}')
print(next(my_generator))
```

读取元素的形式也与迭代器相同，可以使用`for`遍历。

```python
my_generator = (i for i in range(3))

for value in my_generator:
    print(f'当前元素为: {value}')
```

### 函数生成器

在定义函数时，使用`yield`关键字来返回值，就是函数生成器。

```python
def my_generator(n):
    for i in range(n):
        print('start...')
        yield i
        print('end...')
        
g = my_generator(3)
print(g)
print(f'当前元素为: {next(g)}')
print(f'当前元素为: {next(g)}')
print(f'当前元素为: {next(g)}')
print(next(g))
```

1. 生成器函数每次调用`yield`时，生成器函数的执行就会暂停，并返回`yield`的值。

2. 生成器在下一次调用时会从上次暂停的地方继续执行。

3. 数据生成完成，会抛出一个`StopIteration`异常。

定义一个斐波那契数量的函数生成器

```python
def fibonacci(num):
    a = 0
    b = 1
    
    current_index = 0
    while current_index < num:
        result = a
        a, b = b, a + b
        current_index += 1
        yield result

fib = fibonacci(10)
result = []
for value in fib:
    result.append(value)
print(result)
```

统计函数生成器的运算时间

```python
@time_it
def def_fibonacci(num):
    fib = fibonacci(num)
    result = []
    for value in fib:
        result.append(value)

def_fibonacci(5000)
```

## 可迭代对象

可迭代对象是一种可以返回迭代器的对象，列表、元组、字符串、字典、集合都是可迭代对象。这些对象实现了 `__iter__()`方法，返回一个迭代器。

<img src="https://raw.githubusercontent.com/hughxusu/lesson-py/develop/images/base/2177978-20201018205525401-1392476113.png" style="zoom:90%;" />

验证对象是否可迭代

```python
from collections.abc import Iterable

my_generator = (i for i in range(3))
msg = '插脚红尘已是颠，更求平地上青天。'

print(f'list是否可迭代: {isinstance([1, 2, 3], Iterable)}') 
print(f'generator是否可迭代: {isinstance(my_generator, Iterable)}')
print(f'字符串是否可迭代: {isinstance(msg, Iterable)}')
print(f'整数是否可迭代: {isinstance(123, Iterable)}') 
```

