# 上下文管理器与拷贝

## `with`语句与上下文管理器

上下文管理器是一种用于管理资源（如文件、数据库连接、锁等）的机制，它确保资源在使用后被正确清理和释放。Python中上下文管理器通过`with`语句使用。文件通常的打开方法

```python
msg = '''
为有云屏无限娇，
凤城寒尽怕春宵。
无端嫁得金龟婿，
辜负香衾事早朝。
'''

f = open("为有.txt", "w")
f.write(msg)
f.close()
```

Python语言中为上述代码提供更简洁的语法规范，使用`with`语句。

```python
msg = '''
闺中少妇不知愁，
春日凝妆上翠楼。
忽见陌头杨柳色，
悔教夫婿觅封侯。
'''

with open('闺怨.txt', 'w') as f:
    f.write(msg)
```

* 打开文件后返回的对象使用`as f`接收，等价于`f = open("demo.txt", "r")`。
* 使用`with`语句后，执行完成会自动调用关闭文件操作。

### 类上下文管理器

一个类只要实现了`__enter__()`和`__exit__()`这个两个方法，就可以创建上下文管理器。

```python
class File(object):
    # 初始化方法
    def __init__(self, file_name, file_model):
        # 定义变量保存文件名和打开模式
        self.file_name = file_name
        self.file_model = file_model

    # 上文方法
    def __enter__(self):
        print("进入上文方法")
        # 返回文件资源
        self.file = open(self.file_name,self.file_model)
        return self.file

    # 下文方法
    def __exit__(self, exc_type, exc_val, exc_tb):
        print("进入下文方法")
        self.file.close()

# 使用with管理文件
with File("demo.txt", "w") as file:
    file.write("hello world")
```

1. `__enter__`表示上文方法，需要返回一个操作文件对象。
2. `__exit__` 表示下文方法，with语句执行完成会自动执行，即使出现异常也会执行该方法。
3. `__exit__`方法如果返回 `True` ，`with`语句中出现异常将被拦截，不会向上层抛出。

### 函数上下文管理器

Python提供`@contextmanager`装饰器，可以使一个函数成为上下文管理器。

```python
from contextlib import contextmanager

msg = '''
冰簟银床梦不成，
碧天如水夜云轻。
雁声远过潇湘去，
十二楼中月自明。
'''

@contextmanager
def my_open(path, mode):
    file = open(path, mode)
    print("进入上文")
    yield file
    print("进入下文")
    file.close()
        
with my_open('瑶瑟怨.txt', 'w') as f:
    f.write(msg)
```

1. 使用`yield`返回值为函数的返回值，`yield`将函数分割为两部分。
2. `yield`上面的语句类似于`__enter__`方法中的语句。
3. `yield`下面的语句类似于`__exit__`方法中的语句。
4. 装饰函数本身不能处理异常。

## 拷贝

`copy`包可以用来进行数据拷贝。

### 浅拷贝

`copy.copy`浅拷贝函数：只对可变类型的第一层对象进行拷贝，对拷贝的对象开辟新的内存空间进行存储，不会拷贝对象内部的子对象。

```python
import copy

num1 = 1
num2 = copy.copy(num1)
print("num1:", id(num1))
print("num2:", id(num2))

my_tuple1 = (1, [1, 2])
my_tuple2 = copy.copy(my_tuple1)
print("my_tuple1:", id(my_tuple1))
print("my_tuple2:", id(my_tuple2))

my_list1 = [1, 3, [4, 6]]
my_list2 = copy.copy(my_list1)
print("my_list1:", id(my_list1))
print("my_list2:", id(my_list2))

my_list2.append(5)
print("my_list1:", my_list1)
print("my_list2:", my_list2)

my_list1 = [1, 3, [4, 6]]
my_list2 = copy.copy(my_list1)
print("my_list1:", my_list1)
print("my_list2:", my_list2)
my_list1[2].append(3)
print("my_list1:", my_list1)
print("my_list2:", my_list2)
```

1. 不可变类型，进行浅拷贝不会给拷贝的对象，开辟新的内存空间，而只是拷贝了这个对象的引用。
2. 可变类型进行浅拷贝，只对可变类型的第一层对象进行拷贝，拷贝对象会开辟新的内存空间，子对象不进行拷贝。

### 深拷贝

`copy.deepcopy`深拷贝函数：只要发现对象有可变类型就会对该对象到最后一个可变类型的每一层对象就行拷贝, 对每一层拷贝的对象都会开辟新的内存空间进行存储。

```python
import copy

num1 = 1
num2 = copy.deepcopy(num1)
print("num1:", id(num1))
print("num2:", id(num2))

my_tuple1 = (1, [1, 2])
my_tuple2 = copy.deepcopy(my_tuple1)
print("my_tuple1:", id(my_tuple1))
print("my_tuple2:", id(my_tuple2))

my_list1 = (1, [1, 2])
my_list2 = copy.deepcopy(my_list1)
print("my_list1:", my_list1)
print("my_list2:", my_list2)
my_list2[1].append(5)
print("my_list1:", my_list1)
print("my_list2:", my_list2)

my_list1 = [1, 3, [4, 6]]
my_list2 = copy.deepcopy(my_list1)
print("my_list1:", my_list1)
print("my_list2:", my_list2)
my_list2[2].append(5)
print("my_list1:", my_list1)
print("my_list2:", my_list2)
```

1. 不可变类型，进行深拷贝，如果子对象没有可变类型，则不会进行拷贝，而只是拷贝了这个对象的引用。
2. 不可变类型，进行深拷贝如果子对象有可变类型，对每一层数据开辟内存空间，重新复制数据。
3. 可变类型，进行深拷贝，会对每一层元素开辟内存空间，重新复制数据。

> [!warning]
>
> 实际应用中拷贝函数多使用深拷贝，但是深拷贝会耗费大量内存。
