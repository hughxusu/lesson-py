# 闭包与装饰器

在Python中函数内部，可以定义新的函数，闭包和装饰器都是这一语法的应用。

## 闭包

闭包的使用：

1. 定义外部函数
2. 定义内部函数（函数嵌套）
3. 外部函数返回了内部函数

```python
# 1. 定义外部函数
def multiplier_factory(factor):
    
    # 2. 定义内部函数
    def multiplier(number):
        return number * factor
    
    # 3. 外部函数返回了内部函数
    return multiplier

# 创建两个不同的乘法器
double = multiplier_factory(2)
triple = multiplier_factory(3)

print(double(5))  # 输出: 10
print(triple(5))  # 输出: 15
```

上述案例中闭包用于创建工厂函数，它们返回具有不同配置的函数。

闭包的特点：

1. 闭包可以保存外部函数的变量，不会随着外部函数调用完而销毁。
2. 由于闭包引用了外部函数的变量，则外部函数的变量没有及时释放，消耗更多内存。

> [!note]
>
> 闭包的本质是一个函数与其相关的引用环境组合的一个整体（实体），可以看做一个简写的类。

闭包中，外部函数的变量，可以被修改

```python
def make_counter(init=0):
    count = init  # 外层函数的局部变量
    
    def counter():
        nonlocal count  # 使用 nonlocal 声明外层变量
        count += 1
        return count
    
    return counter

# 创建一个计数器实例
my_counter = make_counter()

print(my_counter())  
print(my_counter())  
print(my_counter())  

# 创建另一个计数器实例
another_counter = make_counter(10)

print(another_counter())  
print(another_counter()) 
```

## 装饰器

给已有函数增加额外功能的函数，它本质上就是一个闭包函数。

装饰器的特点：

1. 不修改已有函数的源代码
2. 不修改已有函数的调用方式
3. 给已有函数增加额外的功能

```python
def count_calls(func):
    count = 0
    def wrapper():
        nonlocal count
        count += 1
        print(f"{func.__name__} 函数调用 {count} 次:", end='\t')
        func()
    return wrapper

def greet():
    print(f"Hello, world")

greet = count_calls(greet)
greet()
greet()
```

上面的装饰器相当于给原有的函数，增加了一个计数功能，用来记录函数调用的次数。

装饰器的使用：

1. 闭包函数有且只有一个参数，必须是函数类型，这样定义的函数才是装饰器。

2. 不改变被装饰函数的名称和调用方式。

在python语言中有专门的语法来表示装饰器（语法糖）

```python
@count_calls
def greet():
    print(f"Hello, world")

greet()
greet()
```

这里的`@count_calls`等价于`greet = count_calls(greet)`。

> [!tip]
>
> 实现一个统计函数运算时间的装饰器

使用Python的计时工具包，`time.time()`返回的是从 1970年1月1日00:00:00 UTC （Unix纪元）开始到当前时间的 秒数 ，包括小数部分。

```python
import time

def time_it(func):
    def wrapper():
        start_time = time.time()
        result = func()
        end_time = time.time()
        print(f"{func.__name__} took {end_time - start_time:.4f} seconds")
        return result
    return wrapper


@time_it
def calculate_total():
    total = 0
    for i in range(1000000):
        total += i
    print(f'total = {total}')

calculate_total()
```

### 通用装饰器

1. 装饰带有参数的函数

```python
def count_calls(func):
    count = 0
    def wrapper(name):
        nonlocal count
        count += 1
        print(f"{func.__name__} has been called {count} times")
        func(name)
    return wrapper	

@count_calls
def greet(name):
    print(f"Hello, {name}")

greet("Alice")
greet("Bob")
```

2. 装饰带有不定长参数的函数

```python
def count_calls(func):
    count = 0
    def wrapper(*args, **kwargs):
        nonlocal count
        count += 1
        print(f"{func.__name__} 函数调用 {count} 次:", end='\t')
        func(*args, **kwargs)
    return wrapper

@count_calls
def greet(first, last):
    print(f"Hello, {first.title()} {last.title()}")

greet("john", "doe")
greet("alice", "smith")
```

3. 通用装饰器

```python
def count_calls(func):
    count = 0
    def wrapper(*args, **kwargs):
        nonlocal count
        count += 1
        print(f"{func.__name__} 函数调用 {count} 次:", end='\t')
        return func(*args, **kwargs)
    return wrapper

@count_calls
def greet(first, last):
    return f"Hello, {first.title()} {last.title()}"

print(greet("john", "doe"))
print(greet("alice", "smith"))

```

### 多个装饰器的使用

一个函数可以使用多个装饰器装饰，装饰顺序是由内到外。

```python
def make_div(func):
    def inner(*args, **kwargs):
        return "<div>" + func(*args, **kwargs) + "</div>"
    return inner

def make_p(func):
    def inner(*args, **kwargs):
        return "<p>" + func(*args, **kwargs) + "</p>"
    return inner

@make_p
@make_div
def greet(name):
    return f"Hello, {name}"

result = greet("Alice")
print(result)
```

### 带有参数的装饰器

使用带有参数的装饰器，其实是在装饰器外面又包裹了一个函数，使用该函数接收参数，返回是装饰器。

```python
def make_label(label):
    def decorator(func):
        def inner(*args, **kwargs):
            return f"<{label}>" + func(*args, **kwargs) + f"</{label}>"
        return inner
    return decorator

@make_label('p') # 先调用make_label('p')函数返回装饰器，装饰器与@结合生效。
@make_label('div')
def greet(name):
    return f"Hello, {name}"

result = greet("Alice")
print(result)
```

### 类装饰器的使用

可以通过定义一个类来装饰函数。

```python
class CountCalls:
    def __init__(self, func):
        self.func = func
        self.count = 0
        
    def __call__(self, *args, **kwargs):
        self.count += 1
        print(f"{self.func.__name__} 函数调用 {self.count} 次:", end='\t')
        return self.func(*args, **kwargs)

@CountCalls
def greet(first, last):
    return f"Hello, {first.title()} {last.title()}"

print(greet("john", "doe"))
print(greet("alice", "smith"))
```

1. `@CountCalls`等价于`CountCalls = CountCalls(comment)`，所以需要提供一个`init`方法，并增加`func`参数。
2. 要想类的实例对象能够像函数一样调用，需要在类里面实现`call`方法，把类的实例变成可调用对象(callable)，也就是说可以像调用函数一样进行调用。
3. 在`call`方法里进行对`func`函数的装饰，可以添加额外的功能。

# property属性

定义一个类工具用于小数和百分比的转换

```python
class Ratio(object):
    def __init__(self, value=0):
        self.__value = value

    def percent(self):
        return self.__value * 100
             
ratio = Ratio(0.44)
print(f'当前百分比为: {ratio.percent()}%')
```

`@property`可以把一个方法当做属性进行使用，用于简化代码

```python
class Ratio(object):
    def __init__(self):
        self.__value = 0

    @property
    def percent(self):
        return self.__value * 100
           
ratio = Ratio(0.44)
print(f'当前百分比为: {ratio.percent}%')
```

增加`set_percent`方法用于设置百分比

```python
class Ratio(object):
    def __init__(self, value=0):
        self.__value = value    

    @property
    def percent(self):
        return self.__value * 100
      
    def set_percent(self, value):
        if value > 100:
            self.__value = 1
        elif value < 0:
            self.__value = 0
        else:
            self.__value = value / 100
               
ratio = Ratio()
print(f'当前百分比为: {ratio.percent}%')
ratio.set_percent(44)
print(f'当前百分比为: {ratio.percent}%')
ratio.set_percent(120)
print(f'当前百分比为: {ratio.percent}%')
```

将`set_percent`方法变为`set`属性

```python
class Ratio(object):
    def __init__(self, value=0):
        self.__value = value    

    @property
    def percent(self):
        return self.__value * 100
      
    @percent.setter 
    def percent(self, value):
        if value > 100:
            self.__value = 1
        elif value < 0:
            self.__value = 0
        else:
            self.__value = value / 100
               
ratio = Ratio()
print(f'当前百分比为: {ratio.percent}%')
ratio.percent = 44
print(f'当前百分比为: {ratio.percent}%')
ratio.percent = 120
print(f'当前百分比为: {ratio.percent}%')
```

> [!alert]
>
> 对于耗时时间长的方法不应该变为属性。
