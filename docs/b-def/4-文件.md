# 函数练习

## 序列的保存和读取

### JSON数据格式

JSON（JavaScript Object Notation）是一种文本型的轻量级数据交换格式，常用于网络数据传输或数据保存。JSON数据形式类似于Python中的字典和列表。

```json
[
    {
        "make": "audi",
        "model": "a4",
        "year": 2019
    },
    {
        "make": "bmw",
        "model": "m3",
        "year": 2020
    }
]
```

JSON有6种数据类型

| 数据类型 | 描述             | 示例               |
| :------- | :--------------- | :----------------- |
| String   | 双引号包裹的文本 | `"Hello"`          |
| Number   | 整数或浮点数     | `123`, `12.34`     |
| Boolean  | 逻辑值           | `true`, `false`    |
| Null     | 空值             | `null`             |
| Object   | 无序的键值对集合 | `{"key": "value"}` |
| Array    | 有序的值列表     | `[1, 2, 3]`        |

将Python字典或列表等数据类型转换为JSON（数据序列化）

```python
import json

cars = [
    {'make': 'audi', 'model': 'a4', 'year': 2019},
    {'make': 'bmw', 'model': 'm3', 'year': 2020},
]

f = open('cars.json', 'w', encoding='utf-8')
json.dump(cars, f, ensure_ascii=False, indent=4)
f.close()
```

将JSON数据转化为Python字典或列表（数据反序列化）

```python
import json

f = open('cars.json', 'r', encoding='utf-8')
cars = json.load(f)
f.close()
print(cars)
print(type(cars))
print(type(cars[0]))
```

### Pickle数据格式

Pickle数据格式是一种用于序列化和反序列化Python对象结构的专有二进制协议。通常情况下，Pickle文件通常比同等数据的JSON文件更小。

保存Pickle数据

```python
import pickle

cars = [
    {'make': 'audi', 'model': 'a4', 'year': 2019},
    {'make': 'bmw', 'model': 'm3', 'year': 2020},
]

f = open('cars.pkl', 'wb')
pickle.dump(cars, f)
f.close()

```

读取Pickle数据

```python
import pickle

f = open('cars.pkl', 'rb')
cars = pickle.load(f)
f.close()
print(cars)
print(type(cars))
print(type(cars[0]))
```

## 综合练习

根据`1000_imdb_top.json`中提供的数据完成练习。数据来源于[IMDB Movies Dataset](https://www.kaggle.com/datasets/harshitshankhdhar/imdb-dataset-of-top-1000-movies-and-tv-shows)，包含如下信息：

* Poster_Link—使用的海报链接
* Series_Title—电影名称
* Released_Year—电影上映年份
* Certificate—该电影获得的证书
* Runtime—电影的总运行时间
* Genre—电影类型
* IMDB_Rating—IMDB 网站上的电影评级
* Overview—概述
* Director—导演
* Star1、Star2、Star3、Star4—4位主要演员
* No_of_votes—总投票数
* Gross—总收入

 读取数据打印数据数量

```python
import json

def load_data():
    f = open('1000_imdb_top.json', 'r', encoding='utf-8')
    movies = json.load(f)
    f.close()
    return movies

movies = load_data()
print(f'Number: {len(movies)}')
print('='*50)
for key, value in movies[0].items():
    print(f'{key}: {value}')
```

* 这里将读取数据的过程封装成`load_data`放入`utils`文件中

> [!note]
>
> 统计2000年及以后上映的电影数量。
>
> 提示：`Released_Year`是字符串，比较可以转换为数值类型。

```python
def count_movies_after_2000(movies):
    count = 0
    for movie in movies:
        year_str = movie.get("Released_Year", "").strip()
        if year_str.isdigit():
            year = int(year_str)
            if year >= 2000:
                count += 1
    return count
  
print(f'2000年以后的电影数量{count_movies_after_2000(movies)}')

```

> [!note]
>
> 计算所有电影的平均时长（分钟），超过120分钟的电影数量，小于120分钟的电影数量。
>
> 提示：`Runtime`字段为`"142 min"`，需要提取数字再计算。

```python
def analyze_runtime(movies):
    total_runtime = 0
    count = 0
    over_120 = 0
    under_120 = 0

    for movie in movies:
        runtime_str = movie.get("Runtime", "").strip()
        if runtime_str.endswith("min"):
            number_part = runtime_str.replace("min", "").strip()

            if number_part.isdigit():
                runtime = int(number_part)
                total_runtime += runtime
                count += 1

                if runtime > 120:
                    over_120 += 1
                elif runtime < 120:
                    under_120 += 1

    if count > 0:
        avg_runtime = total_runtime / count
    else:
        avg_runtime = 0

    return avg_runtime, over_120, under_120
  
avg, over_120, under_120 = analyze_runtime(movies)
print(
  f'平均时长{avg:.0f}，超过120分钟的电影数量{over_120}，小于120分钟的电影数量{under_120}'
)
```

> [!note]
>
> 统计IMDB_Rating在某个区间内的电影数量，开始和结束是参数。

```python
def count_movies_by_rating(movies, start, end):
    count = 0
    for movie in movies:
        rating = movie.get("IMDB_Rating", None)

        # 确保 rating 有值并且是数字
        if isinstance(rating, (int, float)):
            if start <= rating <= end:
                count += 1
    return count
```

> [!note]
>
> 统计拍摄电影数量最多的导演，并输出该导演的电影数。

```python
def most_active_director(movies):
    director_count = {}

    for movie in movies:
        director = movie.get("Director", "").strip()
        if director != "":
            if director not in director_count:
                director_count[director] = 1
            else:
                director_count[director] += 1

    max_director = ""
    max_count = 0
    for director, count in director_count.items():
        if count > max_count:
            max_director = director
            max_count = count

    return max_director, max_count
  
max_director, max_count = most_active_director(movies)
print(
  f'拍摄电影数量最多的导演是{max_director}，共执导{max_count}部电影'
)

```

> [!note]
>
> 统计所有电影的票房总和（Gross），并计算有票房数据的电影平均票房。
>
> 提示：票房字段可能为`null`或字符串 `"28,341,469"`，需要去掉逗号并转为整数。

```python
def analyze_gross(movies):
    total_gross = 0
    count = 0

    for movie in movies:
        gross_str = movie.get("Gross", None)

        if gross_str is not None and isinstance(gross_str, str):
            gross_str = gross_str.replace(",", "").strip()

            if gross_str.isdigit():  # 确保是数字
                gross = int(gross_str)
                total_gross += gross
                count += 1

    if count > 0:
        avg_gross = total_gross / count
    else:
        avg_gross = 0

    return total_gross, avg_gross
  
total_gross, avg_gross = analyze_gross(movies)
print(f'总票房{total_gross}，平均票房{avg_gross:.0f}')
```



