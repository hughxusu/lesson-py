# 异常、模块和包

## 异常

程序执行过程期间发生错误，导致程序无法继续执行，称为异常。

```python
f = open('todolist.pkl', 'rb')
```

* 打开一个不存在的文件，程序无法执行，抛出`FileNotFoundError`异常。

### 捕获异常

可以使用`try`—`except`代码块来处理可能的异常。

```python
try:
    f = open('todolist.pkl', 'rb')
except FileNotFoundError:
    print('File not found!')
```

1. `try`代码块中执行有可能出现异常的代码。
2. `except`代码块中执行如果出现错误要运行的代码。
3. 如果没有异常`except`代码不会被执行。
4. `except`关键字后面指定了要处理的异常类型。

### 避免程序崩溃

异常虽然可以终止程序执行，但有时出现异常后并不希望程序终止。创建一个计算器程序

```python
print("Give me two numbers, and I'll divide them.")
print("Enter 'q' to quit.")

while True:
    first_number = input("\nFirst number: ")
    if first_number == 'q':
        break

    second_number = input("Second number: ")
    if second_number == 'q':
        break
        
    answer = int(first_number) / int(second_number)
    print(answer)
```

但`second_number = 0`是会出现异常，增加异常处理代码块。

```python
while True:
    first_number = input("\nFirst number: ")
    if first_number == 'q':
        break

    second_number = input("Second number: ")
    if second_number == 'q':
        break
        
    try:
        answer = int(first_number) / int(second_number)
    except ZeroDivisionError:
        print("You can't divide by 0!")
    else:
        print(answer)
```

* `else`表示的是如果没有异常要执行的代码。

当`first_number = 'a'`和`second_number = 'a'`，程序还会出现异常。

```python
while True:
    first_number = input("\nFirst number: ")
    if first_number == 'q':
        break

    second_number = input("Second number: ")
    if second_number == 'q':
        break
        
    try:
        answer = int(first_number) / int(second_number)
    except (ValueError, ZeroDivisionError) as e:
        print(f"This is an error: {e}")
    else:
        print(answer)
```

* 使用元组可以捕获多个异常，并将捕获的异常类型保存到变量`e`中。

`Exception`是所有程序异常类的父类，使用`Exception`可以捕获任意异常。

```python
while True:
    first_number = input("\nFirst number: ")
    if first_number == 'q':
        break

    second_number = input("Second number: ")
    if second_number == 'q':
        break
        
    try:
        answer = int(first_number) / int(second_number)
    except Exception as e:
        print(f"This is an error: {e}")
    else:
        print(answer)
```

`finally`表示的是无论是否异常都要执行的代码。

```python
while True:
    first_number = input("\nFirst number: ")
    if first_number == 'q':
        break

    second_number = input("Second number: ")
    if second_number == 'q':
        break
        
    try:
        answer = int(first_number) / int(second_number)
    except Exception as e:
        print(f"This is an error: {e}")
    else:
        print(answer)
    finally:
        print(f"first_number = {first_number}, second_number = {second_number}")
```

### 自定义异常

在Python中，自定义异常需要继承`Exception`类，抛出异常使用`raise`关键字。

```python
class NotSameLengthError(Exception):
    def __init__(self):
        super().__init__(self)

    def __str__(self):
        return '输入数组长度必须相同'


def add_two_arr(first, second):
    if len(first) != len(second):
        raise NotSameLengthError()

    results = []
    for i in first:
        result = first[i] + scond[i]
        results.append(result)
    return results

first = [1, 2, 3]
second = [1, 2, 3, 4]

try:
    add_two_arr(first, second)
except NotSameLengthError as e:
    print(e)
```

[python预定义的常用异常](https://docs.python.org/zh-cn/3.14/library/exceptions.html#IndexError)

## TodoList完整版

清单数据的保存和读取。

1. 在`TodoList`类中添加数据保存方法。

```python
def __items_to_pkl(self):
    items = [item.__dict__ for item in self.__items]
    f = open('todoitems.pkl', 'wb')
    pickle.dump(items, f)
    f.close()
```

2. 退出前保存数据

```python
if raw == 'exit':
    self.__items_to_pkl()
    break
```

3. 在`TodoItem`中添加，使用字典来创建新的对象

```python
@classmethod
def from_dict(cls, item_dict):
    item = cls(item_dict['desc'])
    item.is_completed = item_dict['is_completed']
    return item
```

4. 在`TodoList`类中添加数据读取方法。

```python
def __pkl_to_items(self):
    try:
        f = open('todoitems.pkl', 'rb')
        items = pickle.load(f)
        self.__items = [TodoItem.from_dict(item) for item in items]
        f.close()
    except Exception:
        f = open('todoitems.pkl', 'wb')
        f.close()
```

5. 在`run`方法中添加调用数据读取方法

```python
def run(self):
    self.__pkl_to_items()
    print('=' * 100)
    print('欢迎使用任务清单')
    self.__short_info()
```

## 模块

一个Python文件可以看做一个模块，模块能定义函数，类和变量。

### 导入模块

1. 使用`import`导入整个模块。

```python
import math
print(math.sqrt(9))
```

2. 使用` from import`导入单个类、多个类或函数。

```python
from math import sqrt
print(sqrt(9))

from math import sin, fabs
print(sin(3.14159 / 2))
print(fabs(-3))
```

3. 使用`from import *`导入所有函数和类。

```python
from math import *
print(sqrt(9))
```

4. 使用`as`指定别名

```python
# 模块别名
import math as m
print(m.sqrt(9))

# 功能别名
from math import sqrt as sq
print(sq(9))
```

### 自定义模块

在Python中，每个Python文件都可以作为一个模块，模块的名字就是文件的名字。

> [!warning]
>
> 自定义模块名必须要符合标识符命名规则。

1. 创建`todoitem.py`文件，将`TodoItem`类复制到文件中。
2. 创建`todolist.py`文件
   1. 在文件中导入`TodoItem`，如：`from todoitem import TodoItem`。
   2. 将`TodoList`类复制到文件中。

3. 创建`main`，作为入口文件
   1. 在文件中导入`TodoList`，如：`from todolist import TodoList`。
   2. 在入口函数中执行启动程序。


### `__name__`

> [!think]
>
> 如果定义一个类后，如何测试这个类功能是否正确？

Python中，`__name__`是一个特殊变量，用于确定一个模块（文件）是作为主程序运行还是被导入到其他模块中。

```python
print(f'todoitem.py is {__name__}')
```

只有主程序的`__name__`值为`__main__`，被导入文件的`__name__`与文件名相同。在模块中添加测试模块

```python
if __name__ == '__main__':
    item = TodoItem('学习Python')
    print(item)
```

### 模块定位顺序

导入模块时，Python解析器对模块位置的搜索顺序是：

1. 当前目录。
2. 环境变量的配置目录。
3. Python安装默认路径（Linux 系统，默认路径一般为/usr/local/lib/python/）

> [!alert]
>
> 1. 自己的文件名不要和已有模块名重复，否则导致模块功能无法使用。
> 2. 如果使用`from import`或`from import *`导入多个模块的时候，且模块内有同名功能。当调用这个同名功能的时候，调用到的是后面导入的模块的功能。

### `__all__`

`__all__`是一个模块级变量，是一个列表，定义在 Python 模块中，用于控制从模块导入时的行为。

```python
__all__ = ['TodoItem']
```

只有当使用`from import *`时，仅仅导入`__all__`中列出的名字。

## 包

Python中的包就是包含多个模块文件的文件夹，并且在这个文件夹有一个`__init__.py`文件。

### 定义包文件

将话费通知类，转换为包的形式。

1. 创建文件夹note，并添加`__init__.py`文件，转换成包文件。
2. 在包中创建不同的模块
   * 创建`base.py`文件，用于保存`Notification`基类。
   * 创建`email.py`文件，保存`EmailNotification`类，在模块中导入`from .base import Notification`。注意：同一个包内导入模块时需要加`.`。
   * 创建`sms.py`文件，保存`SmsNotification`类。
   * 创建`wx.py`文件，保存`WXNotification`类。
   * 创建`serve.py`文件，保存`NotificationService`类。

### 导入包中的文件

1. 导入指定的函数或类

```python
from note.email import EmailNotification

email_note = EmailNotification('张三', 100, 84, 'zs@example.com')
email_note.send()
```

2. 导入指定模块

导入方式一

```python
import note.sms

sms_note = note.sms.SmsNotification('张三', 100, 84, '13800001234')
sms_note.send()
```

导入方式二

```python
from note import wx

wx_note = wx.WXNotification('张三', 100, 84, 'zs-wx')
wx_note.send()
```

3. 导入全部模块

在`__init__.py`文件中添加`__all__ = []`，控制允许导入的模块列表。

```python
__all__ = ['email', 'sms', 'wx', 'serve']
```

导入全部模块

```python
from note import email, sms, wx, serve

email_note = email.EmailNotification('张三', 100, 84, 'zs@example.com')
sms_note = sms.SmsNotification('张三', 100, 84, '13800001234')
wx_note = wx.WXNotification('张三', 100, 84, 'zs-wx')

service = serve.NotificationService()
service.add_notification(email_note)
service.add_notification(sms_note)
service.add_notification(wx_note)

service.send_all()
```

使用`*`代替全面模块

```python
from note import *
```

如果在`__init__.py`文件中没有`__all__`，无法使用`*`导入全部模块。



