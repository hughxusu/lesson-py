# 面向对象综合练习

[pygame](https://www.pygame.org/news)是一款专门为开发和2D电子游戏的开源软件包，支持Windows、Linux和Mac OS等操作系统。它是在SDL（Simple DirectMedia Layer）的基础上开发而成。安装pygame

```python
pip install pygame
```

* [pygame基础教程](https://www.bilibili.com/video/BV11LJazcExL?spm_id_from=333.788.videopod.episodes&vd_source=c5271ca82571b2b45d1adc27aa9f3275)
* [完整的坦克大战项目](https://github.com/HelloZhan/pygame-TankWar)

## pygame基本使用

游戏的基本流程

```python
import pygame as pg

pg.init()
window = pg.display.set_mode((800, 600))
clock = pg.time.Clock()
is_running = True

while is_running:
    for event in pg.event.get():
        if event.type == pg.QUIT:
            is_running = False

    clock.tick(60)
    pg.display.update()
    
pg.quit()
```

* `pg.init()`和`pg.quit()`分别表示：初始化和结束游戏
* `pg.display.set_mode((800, 600))`创建一个游戏区域。
* `while is_running:`游戏本身是一个死循环。
* `pg.event.get()`获取游戏中的事件，如：点击鼠标、按按钮。
* `clock = pg.time.Clock()`创建时钟对象跟踪时间。
* `clock.tick(60)`定义游戏的帧率。
* `pg.display.update()`刷新屏幕显示的内容。

## 坦克大战

项目目录

```shell
.
├── bullet.py         # 子弹类
├── game.py           # 游戏流程控制
├── images            # 素材文件夹
├── main.py           # 入库函数
├── player.py         # 玩家类
└── utils.py          # 辅助元素
```

程序入口函数

```python
from game import Game

if __name__ == '__main__':
    game = Game()
    game.run()
```

游戏主循环

```python
import sys
import pygame as pg
from player import Player
from utils import Delay

class Game:
    _instance = None

    def __new__(cls, *args, **kwargs):
        if cls._instance is None:
            cls._instance = super().__new__(cls)
        return cls._instance

    def __init__(self):
        pg.init()
        self.screen = pg.display.set_mode((720, 720))
        pg.display.set_caption('Tank fight!')
        self.clock = pg.time.Clock()
        
        self.all_sprites = pg.sprite.Group()
        self.player = Player(360, 360)
        self.all_sprites.add(self.player)
        self.delay = Delay()

    def renew(self):
        self.delay.update()
        self.clock.tick(60)
        pg.display.update()

    def run(self):
        while True:
            for event in pg.event.get():
                if event.type == pg.QUIT:
                    pg.quit()
                    sys.exit()
            
            keys = pg.key.get_pressed()
            self.all_sprites.update(keys)
            
            self.screen.fill((0, 0, 0))
            self.all_sprites.draw(self.screen)
            self.renew()
```

* `self.all_sprites.update(keys)`更新页面中元素的参数。
* `self.all_sprites.draw(self.screen)`绘制页面中所有元素。

`utils.py`包含多个常量和工具类，`Delay`是一个计时器类，倒计时100个数后重置，用于控制坦克移动动画。

```python
class Delay:
    _instance = None

    def __new__(cls, *args, **kwargs):
        if cls._instance is None:
            cls._instance = super().__new__(cls)
        return cls._instance

    def __init__(self):
        self.count = 100

    def update(self):
        self.count -= 1

        if not self.count:
            self.count = 100
```

游戏玩家类

```python
import pygame as pg
import utils
from utils import Delay
from bullet import Bullet

TANK_IMG = r"images/tank_T1_0.png"

class Player(pg.sprite.Sprite):
    def __init__(self, x, y):
        super().__init__()

        self.tank = pg.image.load(TANK_IMG).convert_alpha()
        self.direction = None
        self.set_direction_image(utils.UP)
        self.image = self.tank_R0

        self.rect = self.image.get_rect()
        self.rect.x = x
        self.rect.y = y
        self.speed = 2
        self.delay = Delay()
        self.last_fire_time = 0
       
    def switch_image(self):
        if self.delay.count % 5 == 0:
            self.image = self.tank_R1 if self.image == self.tank_R0 else self.tank_R0

    def set_direction_image(self, d):
        if self.direction != utils.UP and d == utils.UP:
            self.tank_R0 = self.tank.subsurface((0, 0), (48, 48))
            self.tank_R1 = self.tank.subsurface((48, 0), (48, 48))
        elif self.direction != utils.DOWN and d == utils.DOWN:
            self.tank_R0 = self.tank.subsurface((0, 48), (48, 48))
            self.tank_R1 = self.tank.subsurface((48, 48), (48, 48))
        elif self.direction != utils.LEFT and d == utils.LEFT:
            self.tank_R0 = self.tank.subsurface((0, 96), (48, 48))
            self.tank_R1 = self.tank.subsurface((48, 96), (48, 48))
        elif self.direction != utils.RIGHT and d == utils.RIGHT:
            self.tank_R0 = self.tank.subsurface((0, 144), (48, 48))
            self.tank_R1 = self.tank.subsurface((48, 144), (48, 48))
        self.direction = d

    def is_ready_to_fire(self):
        current_time = pg.time.get_ticks()
        if current_time - self.last_fire_time >= utils.BULLET_COOL_DOWN:
            self.last_fire_time = current_time
            return True
        return False

    def fire(self):
        if self.is_ready_to_fire():
            bullet = Bullet(self.direction, self)
            group = self.groups()[0]
            group.add(bullet)
            self.fire_cool_down = False

    def update(self, keys):
        if keys[pg.K_LEFT]:
            self.set_direction_image(utils.LEFT)
            self.rect.x -= self.speed
            self.switch_image()
        if keys[pg.K_RIGHT]:
            self.set_direction_image(utils.RIGHT)
            self.rect.x += self.speed
            self.switch_image()
        if keys[pg.K_UP]:
            self.set_direction_image(utils.UP)
            self.rect.y -= self.speed
            self.switch_image()
        if keys[pg.K_DOWN]:
            self.set_direction_image(utils.DOWN)
            self.rect.y += self.speed
            self.switch_image()
        if keys[pg.K_SPACE]:
            self.fire()

        screen_rect = utils.get_screen_rect()
        self.rect.x = max(0, min(self.rect.x, screen_rect.width - self.rect.width))
        self.rect.y = max(0, min(self.rect.y, screen_rect.height - self.rect.height))
```

* `pg.sprite.Sprite`继承精灵类
  * 覆盖`self.image`属性，框架会在自动重绘时自动调用该属性。
  * 覆盖`self.rect`属性，用于重绘值标注元素的位置。
  * 重写`def update(self, keys)`方法，重绘时会自动调用该方法。
* `utils.get_screen_rect()`获取窗口边界，让坦克在窗口范围内。

子弹类

```python
import pygame as pg
import utils

BULLET_IMG_UP = r"images/bullet_up.png"
BULLET_IMG_DOWN = r"images/bullet_down.png"
BULLET_IMG_LEFT = r"images/bullet_left.png"
BULLET_IMG_RIGHT = r"images/bullet_right.png"

class Bullet(pg.sprite.Sprite):
    def __init__(self, direction, owner):
        super().__init__()
        self.direction = direction
        if self.direction == utils.UP:
            self.image = pg.image.load(BULLET_IMG_UP).convert_alpha()
        elif self.direction == utils.DOWN:
            self.image = pg.image.load(BULLET_IMG_DOWN).convert_alpha()
        elif self.direction == utils.LEFT:
            self.image = pg.image.load(BULLET_IMG_LEFT).convert_alpha()
        elif self.direction == utils.RIGHT:
            self.image = pg.image.load(BULLET_IMG_RIGHT).convert_alpha()
        self.speed = 5

        self.rect = self.image.get_rect()
        self.rect.center = owner.rect.center
        
    def update(self, keys):
        if self.direction == utils.UP:
            self.rect.y -= self.speed
        elif self.direction == utils.DOWN:
            self.rect.y += self.speed
        elif self.direction == utils.LEFT:
            self.rect.x -= self.speed
        elif self.direction == utils.RIGHT:
            self.rect.x += self.speed
        
        screen_rect = utils.get_screen_rect()
        if not self.rect.colliderect(screen_rect):
            self.kill()
```

* `self.rect.colliderect(screen_rect)`子弹碰撞检测。



